//Напишите функцию pow(x,n), которая возвращает x в степени n. Иначе говоря, умножает x на себя n раз и возвращает результат. Функция обязана поддерживать только натуральные значения n. Встроенную операцию возведения в степень использовать нельзя.

function pow(x, n) {
  let res = 1;
  for (i = 0; i < n; i++) {
    res = res * x;
  }
  return res;
}


console.log(pow(4, 5));

//Напишите функцию gcd(a,b), которая возвращает x -- наибольший общий делитель двух неотрицательных чисел  a и  b . Встроенные функции использовать нельзя.

function gcd(a, b) {
  let x = 1;
  for (i = 2; i <= a; i++) {
    if (a % i == 0 && b % i == 0) {
      x = i;
    }
  }
  return x;
}

console.log(gcd(345, 574));

//Напишите функцию minDigit(x), которая возвращает наименьшую цифру целого неотрицательного числа x . Встроенные функции использовать нельзя.

function minDigit(x) {
  let min = 9;
  while (x > 0) {
    if (x % 10 < min) {
      min = x % 10;
    }
    x = Math.floor(x / 10);
  }
  return min;
}

console.log(minDigit(345));

//Зачастую на веб-странице необходимо вывести количество каких-либо элементов (например, сколько записей было найдено в результате поискового запроса). В связи с этим возникает необходимость правильно определить форму множественного числа слов (англ. pluralization). Например: 1 запись, 2 записи, 5 записей, и т. д. В данной задаче требуется написать функцию pluralizeRecords(n), которая для любого целого неотрицательного значения n вернёт строку "В результате выполнения запроса было найдено n записей", в которой для каждого слова будет образована правильная форма множественного числа, в зависимости от конкретного значения n. Для русского языка правила формирования формы множественного числа можно найти по ссылке (нас интересуют правила для one, few и many).

function plurializeRecords(n) {
  if (n % 10 == 1 && n % 100 != 11) {
    return n + ' запись';
  }
  else if (n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20)) {
    return n + ' записи';
  }
  else {
    return n + ' записей';
  }
}

console.log(plurializeRecords(10))

//Реализуйте функцию fibb(n), которая для любого целого неотрицательного числа n <= 1000 вернёт n-ое число из последовательности Фибоначчи.

function fibb(n) {
  let x = 1;
  let y = 1;
  let z = 0;
  for (i = 2; i < n; i++) {
    z = x + y;
    x = y;
    y = z;
  }
  return z;
}

console.log(fibb(900))

//Реализовать сортировку пузырьком. Функция bubbleSort должна принимать в качестве аргумента массив, который нужно отсортировать, изменять его на месте, и возвращать его же после сортировки. Предполагается, что в массиве могут содержаться только числовые значения.

function bubbleSort(arr) {
  let n = arr.length;
  let x = 0;
  for (i = 0; i < n; i++) {
    for (j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        x = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = x;
      }
    }
  }
  return arr;
}
arr1 = [9,6,8,5,7,9,7,5,8]
console.log(bubbleSort(arr1))

//Дана последовательность целых чисел а1, а2, …, аn. Выяснить, сколько чисел и какие входят в последовательность более чем по одному разу. Реализовать функцию, которая должна принимать в качестве аргумента массив и возвращать объект, свойства которого будут соответствовать числам, которые встретились в массиве более одного раза, а значения -- количеству вхождений данного числа в последовательность.

function f(arr) {
  let obj = {};
  for (i = 0; i < arr.length; i++) {
    if (obj[arr[i]] == undefined) {
      obj[arr[i]] = 1;
    }
    else {
      obj[arr[i]] += 1;
    }
  }
  return obj;
}
arr2 = [9,6,8,5,7,9,7,5,8]
console.log(f(arr2))

//Реализовать функцию, которая в качестве аргумента принимает прямоугольную матрицу и возвращает наибольший из минимальных элементов строк матрицы.

function maxMin(arr) {
  let min = arr[0][0];
  for (i = 0; i < arr.length; i++) {
    for (j = 0; j < arr[i].length; j++) {
      if (arr[i][j] < min) {
        min = arr[i][j];
      }
    }
  }
  return min;
}
arr3 = [[1,2,3],[4,5,6],[6,7,8]]
console.log(maxMin(arr3))
//Реализовать объект, описывающий вектор. Хранит координаты конца вектора в 3-мерном пространстве выходящего из начала координат. Методы: сумма двух векторов, произведение двух векторов (покомпонентное), разность двух векторов, умножение вектора на скаляр, длина вектора, скалярное произведение векторов.

let vector = {
  x: 1,
  y: 2,
  z: 3,
  sum: function(vec) {
    return this.x + vec.x + this.y + vec.y + this.z + vec.z;
  },
  prod: function(vec) {
    return this.x * vec.x + this.y * vec.y + this.z * vec.z;
  },
  diff: function(vec) {
    return this.x - vec.x - this.y - vec.y - this.z - vec.z;
  },
  mult: function(num) {
    return this.x * num + this.y * num + this.z * num;

  },
  len: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  scal: function(vec) {
    return this.x * vec.x + this.y * vec.y + this.z * vec.z;
  }
}

console.log(vector.sum(vector))

//Дан массив целых чисел {ai} (i=1, 2, …,n), целое число k (k > 0). Реализовать функцию, которая осуществляет циклический сдвиг значений компонентов массива влево на k компонент.

function f(arr, k) {
  let arr2 = [];
  for (i = 0; i < arr.length; i++) {
    arr2.push(arr[i]);
  }
  for (i = 0; i < k; i++) {
    arr2.push(arr2[0]);
    arr2.shift();
  }
  return arr2;
}
arr4 = [3,6,4,6,8,9,3,5,7,6,3]
k1 = 3
console.log(f(arr4, k1))
//Напишите функцию getSortedArray(array, key), которая сортирует массив объектов. У функции должно быть два параметра: array -- массив объектов, который нужно отсортировать, и key -- ключ, по значению которого нужно произвести сортировку. Предполагается, что свойство с указанным ключом существует у всех объектов в массиве и его значение не пусто. Значением свойства может быть число или строка. Порядок сортировки -- по возрастанию. Пример работы функции приведён в файле. Встроенные функции использовать нельзя.

function getSortedArray(array, key) {
  let arr = [];
  for (i = 0; i < array.length; i++) {
    arr.push(array[i][key]);
  }
  arr.sort(function(a, b) { return a - b });
  let arr2 = [];
  for (i = 0; i < array.length; i++) {
    for (j = 0; j < array.length; j++) {
      if (arr[i] == array[j][key]) {
        arr2.push(array[j]);
      }
    }
  }
  return arr2;
}

console.log(getSortedArray(arr2, 4))
//Напишите функцию cesar(str, shift, action), которая производит шифрование и дешифровку строки str с использованием шифра Цезаря. В качестве алфавита необходимо использовать русский алфавит. Символы, не входящие в алфавит, оставлять неизменными. Параметр shift отвечает за сдвиг алфавита. Если action == 'encode', функция должна производить шифрование, а если action == 'decode' -- дешифровку. Расшифруйте сообщение "эзтыхз фзъзъз", ответ приведите в комментарии в файле с кодом программы.

function cesar(str, shift, action) {
  string = ''
  for (i = 0; i < str.length; i++) {
    if (str[i] == ' ') {
      string += ' ';
      continue;
    }
    if (action == 'encode') {
      string += String.fromCharCode(str[i].charCodeAt(0) + shift);
    }
    if (action == 'decode') {
      string += String.fromCharCode(str[i].charCodeAt(0) - shift);
    }
  }
  return string;
}
;
console.log(cesar('эзтыхз фзъзъз', 3, 'decode'))
